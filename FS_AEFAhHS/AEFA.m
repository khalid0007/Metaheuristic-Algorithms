function [harmony, finalPerformance] = AEFA(X, prevFitness, currIter, MaxIteration)
% Feature selection using AEFA
% Paper : "AEFA : Artificial electrical field algorithm for Global Optimization"
% Author : Anita & Anupam Yadav

% ========<Steps Of Artificial Electrical Field Algorithm>===========
% Step 1: Intialise the population
% Step 2: Calculate charge for each in agent in population
% Step 3: Calculate complete electric field for each charge
% Step 4: Update velocity
% Step 5: Update position of charged agents
% Step 6: If breaking condition is not met continue from step 2
% Step 7: Best fitness value is considered as the optimal solution
% generated by the metaheuristic algo
% <================================================================>

% Code Author: Khalid Hassan Sheikh
% BCSE, Jadavpur University (2018-2022)

% ========================<INITIALISATION OF VARIABLE>=======================
global trainFeatures trainLabels testFeatures testLabels classifierName paramValue;
populationSize = size(X, 1);
% Position after each iteration
P = X;
velocity = zeros(size(X));
% Coulomb's constant after each iteration
K0 = 500;

% Intialise indivisuals
% initialPerformance = calFitness(trainFeatures, trainLabels, testFeatures, testLabels, ones([1, featureLength]), classifierName, paramValue);
finalPerformance = 0.00; 
bestFitness = 0.00;
bestIndx = 0;
alpha = 10;
    
for iteration = 1:1
%     fprintf("Iteration: %d, Final Accuracy: %f, Initial Accuracy: %f\n", iteration, finalPerformance, initialPerformance);
    % Calculate charge from last updated fitness
    K = K0*exp(alpha*-1*(currIter/MaxIteration));
    charges = calCharges(prevFitness);
    velocity = rand()*velocity + calEF(X, P, charges, K);
    temp = (2*X - 1) + velocity;
    X = SFunction(temp);
    currFitness = calFitness(trainFeatures, trainLabels, testFeatures, testLabels, X, classifierName, paramValue);
    
    for j = 1:populationSize
        if currFitness(j,1) > prevFitness(j, 1)
            prevFitness(j, 1) = currFitness(j,1);
            P(j, :) = X(j, :);
        end
        
        if bestFitness < prevFitness(j, 1)
            bestFitness = prevFitness(j, 1);
            bestIndx = j;
        end
    end
    
    finalPerformance = modifiedClassify(trainFeatures, trainLabels, testFeatures, testLabels, P(bestIndx, :), classifierName, paramValue);
end

fprintf("Final Accuracy: %f\n", finalPerformance);
harmony = [P, prevFitness];

end

function [T] = SFunction(X)
T = zeros(size(X));

for i = 1:size(X, 1)
    for j = 1:size(X, 2)
        temp = sigmoid(X(i, j), 0, 100000.00);
        if temp >= 0
            T(i,j) = 1;
        else
            T(i,j) = 0;
        end
    end
end

end


% Calculate the fitness value for each agent


function [charges] = calCharges(fitness)
% q(i) = exp((fitness(i) - worst)/(best - worst));
numAgents = size(fitness, 1);
charges = zeros([numAgents, 1]);

worst = 2.00;
best = 0.00;

for i = 1:numAgents
   if worst > fitness(i,1)
       worst = fitness(i,1);
   end
   if best < fitness(i,1)
       best = fitness(i,1);
   end
end

for i = 1:numAgents
    charges(i, 1) = exp((fitness(i,1) - worst)/(fitness(i,1) - best));
end

end


function [EF] = calEF(X, P, charges, K)
numAgents = size(X, 1);
featureLength = size(X, 2);
EF = zeros([numAgents, featureLength]);

for i = 1:numAgents
    for j = 1:numAgents
        if i == j
            continue;
        end
        EF(i, :) = EF(i, :) + (rand()*K*charges(i)*charges(j)/calDist(X(i, :), X(j, :))).*(P(j, :) - X(i, :));
    end
end

end

function [dist] = calDist(xi, xj)
    temp = (xi - xj);
    temp = temp.*temp;
    dist = sum(temp) + 0.0001;
end



